
"""
osc_protocol provide the OSC protocol to Twisted.
It is base and using the pyOSC module from V2 (http://trac.v2.nl/wiki/pyOSC).

Many of the Osc methods are taken and adapted from the OSCRequestHandler class of the OSC module.
For each OSC address we look if there's a callback method binded to it and call it with the message arguments.  
"""


# system imports
import types

# twisted imports
from twisted.internet import reactor, protocol

# OSC imports
import OSC


class OscMessage(OSC.OSCMessage):
    """Bindings to the OSC.OSCMessage Class so we can call OscMessage instead of OSC.OSCMessage"""
    pass


class OscBundle(OSC.OSCBundle):
    """Bindings to the OSC.OSCBundle Class so we can call OscBundle instead of OSC.OSCBundle"""
    pass


class Osc(protocol.DatagramProtocol):
    """Base class for OSC clients and servers."""
    
    def __init__(self):
         self.callbacks = {}       
        
    def datagramReceived(self, datagram, addr):
        """Called when a datagram is received.

        @param datagram: the string received from the transport.
        @param addr: tuple of source of datagram.
        """
        self.client_host, self.client_port = addr
#        print "received %r from %s:%d" % (OSC.decodeOSC(datagram), self.client_host, self.client_port)
        self.packet = datagram
        self.replies = []
        self.handle()

    def connectionRefused(self):
        """Called due to error from write in connected mode.

        Note this is a result of ICMP message generated by *previous*
        write.
        """

    def send_message(self, host, port, msg):
        """Send a message.
        """
        if not isinstance(msg, OscMessage):
            raise TypeError("'msg' argument is not an OscMessage or OscBundle object")
        self.transport.write(msg.getBinary(), (host, port))

    def add_msg_handler(self, address, callback):
        """Register a handler for an OSC-address
          - 'address' is the OSC address-string. 
        the address-string should start with '/' and may not contain '*'
          - 'callback' is the function called for incoming OSCMessages that match 'address'.
        The callback-function will be called with the same arguments as the 'msgPrinter_handler' below
        """
        for chk in '*?,[]{}# ':
            if chk in address:
                raise OscError("OSC-address string may not contain any characters in '*?,[]{}# '")
        
        if type(callback) not in (types.FunctionType, types.MethodType):
            raise OscError("Message callback '%s' is not callable" % repr(callback))
        
        if address != 'default':
            address = '/' + address.strip('/')
            
        self.callbacks[address] = callback
        
    def del_msg_handler(self, address):
        """Remove the registered handler for the given OSC-address
        """
        del self.callbacks[address]
 
    def dispatch_message(self, pattern, tags, data):
        """Attmept to match the given OSC-address pattern, which may contain '*',
        against all callbacks registered with the OSCServer.
        Calls the matching callback and returns whatever it returns.
        If no match is found, and a 'default' callback is registered, it calls that one,
        or raises NoCallbackError if a 'default' callback is not registered.
        
          - pattern (string):  The OSC-address of the receied message
          - tags (string):  The OSC-typetags of the receied message's arguments, without ','
          - data (list):  The message arguments
        """
        if len(tags) != len(data):
            raise OscError("Malformed OSC-message; got %d typetags [%s] vs. %d values" % (len(tags), tags, len(data)))
        
        expr = OSC.getRegEx(pattern)
        
        replies = []
        matched = 0
        for addr in self.callbacks.keys():
            match = expr.match(addr)
            if match and (match.end() == len(addr)):
                reply = self.callbacks[addr](pattern, tags, data, (self.client_host, self.client_port))
                matched += 1
                if isinstance(reply, OscMessage):
                    replies.append(reply)
                elif reply != None:
                    raise TypeError("Message-callback %s did not return OSCMessage or None: %s" % (self.callbacks[addr], type(reply)))
                    
        if matched == 0:
            if 'default' in self.callbacks:
                reply = self.callbacks['default'](pattern, tags, data, (self.client_host, self.client_port))
                if isinstance(reply, OscMessage):
                    replies.append(reply)
                elif reply != None:
                    raise TypeError("Message-callback %s did not return OSCMessage or None: %s" % (self.server.callbacks['default'], type(reply)))
#            else:
#                raise OSC.NoCallbackError(pattern)
        
        return replies
        
    def _unbundle(self, decoded):
        """Recursive bundle-unpacking function"""
        if decoded[0] != "#bundle":
            self.replies += self.dispatch_message(decoded[0], decoded[1][1:], decoded[2:])
            return
        
        now = time.time()
        timetag = decoded[1]
        if (timetag > 0.) and (timetag > now):
            reactor.callLater(timetag - now, self._keep_unbundle, decoded)
#            time.sleep(timetag - now) # TO CORRECT !!!
        
    def _keep_unbundle(self, decoded):
        for msg in decoded[2:]:
            self._unbundle(msg)
        
    def handle(self):
        """Handle incoming OSCMessage
        """
        decoded = OSC.decodeOSC(self.packet)
        if not len(decoded):
            return
        
        self._unbundle(decoded)
           
    
class OscError(OSC.OSCError):
    """Class for all OSCServer errors
    """
    pass



def test(pattern, tags, data, addr):
    print pattern
    print tags
    print data
    print addr
    message = OscMessage()
    message.setAddress('/allo')
    message.append('grrr')
    s.send_message(addr[0], addr[1], message)
#    return message

def client():
    """Client example"""
    message = OscMessage()
    message.setAddress('/allo')
    message.append('grrr')
    message.append(34)
    c.send_message('127.0.0.1', 22223, message)
    reactor.stop()


if __name__ == "__main__":
    
    # Server example but can be both at the same time
    s = Osc()
    reactor.listenUDP(22223, s)
    s.add_msg_handler('/allo', test)
    reactor.run()
    
    # Client example
    """
    c = Osc()
    reactor.listenUDP(0, c)
    reactor.callLater(1, client)
    reactor.run()
    """
